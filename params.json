{"name":"ary","tagline":"clips function argument lengths.","body":"# Synopsis\r\n\r\n**ary** is a JavaScript function for restricting a function to a given number of arguments (i.e. capping its *arity*).\r\n\r\n[![stability 5 - locked](http://b.repl.ca/v1/stability-5_--_locked-blue.png)\r\n](http://nodejs.org/api/documentation.html#documentation_stability_index) [![license - Unlicense](http://b.repl.ca/v1/license-Unlicense-lightgrey.png)](http://unlicense.org/) [![Flattr this](https://api.flattr.com/button/flattr-badge-large.png)](https://flattr.com/submit/auto?user_id=pluma&url=https://github.com/pluma/ary)\r\n\r\n[![browser support](https://ci.testling.com/pluma/ary.png)](https://ci.testling.com/pluma/ary)\r\n\r\n[![Build Status](https://travis-ci.org/pluma/ary.png?branch=master)](https://travis-ci.org/pluma/ary) [![Coverage Status](https://coveralls.io/repos/pluma/ary/badge.png?branch=master)](https://coveralls.io/r/pluma/ary?branch=master) [![Dependencies](https://david-dm.org/pluma/ary.png?theme=shields.io)](https://david-dm.org/pluma/ary)\r\n\r\n# Why?\r\n\r\nIt's trivial to implement, but in order to keep code DRY (and avoid silly mistakes) it makes sense to define this function only once per project. This library is the logical consequence of that.\r\n\r\n# Install\r\n\r\n## Node.js\r\n\r\n### With NPM\r\n\r\n```sh\r\nnpm install ary\r\n```\r\n\r\n### From source\r\n\r\n```sh\r\ngit clone https://github.com/pluma/ary.git\r\ncd ary\r\nnpm install\r\nmake\r\n```\r\n\r\n## Browser\r\n\r\n### With component\r\n\r\n```sh\r\ncomponent install pluma/ary\r\n```\r\n\r\n[Learn more about component](https://github.com/component/component).\r\n\r\n### With bower\r\n\r\n```sh\r\nbower install ary\r\n```\r\n\r\n[Learn more about bower](https://github.com/twitter/bower).\r\n\r\n### With a CommonJS module loader\r\n\r\nDownload the [latest minified CommonJS release](https://raw.github.com/pluma/ary/master/dist/ary.min.js) and add it to your project.\r\n\r\n[Learn more about CommonJS modules](http://wiki.commonjs.org/wiki/Modules/1.1).\r\n\r\n### With an AMD module loader\r\n\r\nDownload the [latest minified AMD release](https://raw.github.com/pluma/ary/master/dist/ary.amd.min.js) and add it to your project.\r\n\r\n[Learn more about AMD modules](http://requirejs.org/docs/whyamd.html).\r\n\r\n### As a standalone library\r\n\r\nDownload the [latest minified standalone release](https://raw.github.com/pluma/ary/master/dist/ary.globals.min.js) and add it to your project.\r\n\r\n```html\r\n<script src=\"/your/js/path/ary.globals.min.js\"></script>\r\n```\r\n\r\nThis makes the `ary` function available in the global namespace.\r\n\r\n# Basic usage example\r\n\r\n```javascript\r\nvar ary = require('ary');\r\nvar array = [1, 2, 3, 4];\r\nvar log = console.log.bind(console);\r\n\r\narray.forEach(log); // passes in three arguments: item, index, array\r\n/* Console output:\r\n1, 0, [1, 2, 3, 4]\r\n2, 1, [1, 2, 3, 4]\r\n3, 2, [1, 2, 3, 4]\r\n4, 3, [1, 2, 3, 4]\r\n*/\r\n\r\narray.forEach(ary(1, log)); // only logs the first argument: item\r\n/* Console output:\r\n1\r\n2\r\n3\r\n4\r\n*/\r\n```\r\n\r\n# Advanced usage example\r\n\r\n```javascript\r\nvar ary = require('ary');\r\n\r\n// Our example function: takes any number of arguments\r\n// and returns them as a dash-separated string\r\nfunction dashed() {\r\n  return Array.prototype.slice.call(arguments).join('-');\r\n}\r\ndashed('a', 'b', 'c', 'd'); // 'a-b-c-d';\r\n\r\n// We can create re-usable decorators\r\nvar nullary = ary(0);\r\nvar unary = ary(1);\r\nvar binary = ary(2);\r\n\r\nvar dashed0 = nullary(dashed);\r\ndashed0('a', 'b', 'c', 'd'); // ''\r\n\r\nvar dashed1 = unary(dashed);\r\ndashed1('a', 'b', 'c', 'd'); // 'a'\r\n\r\n// Named arity functions for 0 to 3 are included out of the box:\r\nvar dashed2 = ary.binary(dashed);\r\ndashed2('a', 'b', 'c', 'd'); // 'a-b'\r\n\r\n// Or pass both arguments at once!\r\nvar dashed3 = ary(3, dashed);\r\ndashed3('a', 'b', 'c', 'd'); // 'a-b-c'\r\n\r\n// If a wrapped function is called with less arguments,\r\n// they will be set to `undefined`:\r\n\r\ndashed2('a'); // 'a-'\r\ndashed3('a'); // 'a--'\r\n\r\n// Although the original function has no length ...\r\ndashed.length; // 0\r\n\r\n// ... the wrapped functions always have the expected length!\r\ndashed0.length; // 0\r\ndashed1.length; // 1\r\ndashed2.length; // 2\r\ndashed3.length; // 3\r\n\r\n// If the function is named, the wrapped function retains the name!\r\ndashed.name; // 'dashed'\r\ndashed0.name; // 'dashed'\r\ndashed0.name === dashed.name; // true\r\ndashed1.name === dashed.name; // true\r\ndashed2.name === dashed.name; // true\r\ndashed3.name === dashed.name; // true\r\n```\r\n\r\n# API\r\n\r\n## ary(arity:Number, func:Function):Function\r\n\r\nWraps the given function in a new function of the given arity.\r\n\r\nIf the wrapped function is called with more than `arity` arguments, any additional arguments will be dropped.\r\n\r\nIf the wrapped function is called with less than `arity` arguments, any missing arguments will be set to `undefined`.\r\n\r\n## ary(arity:Number):Function\r\n\r\nReturns a function that will wrap a function in a new function of the given arity.\r\n\r\n## ary.nullary(func:Function):Function\r\n\r\nShorthand for `ary(0, func)`.\r\n\r\n## ary.unary(func:Function):Function\r\n\r\nShorthand for `ary(1, func)`.\r\n\r\n## ary.binary(func:Function):Function\r\n\r\nShorthand for `ary(2, func)`.\r\n\r\n## ary.ternary(func:Function):Function\r\n\r\nShorthand for `ary(3, func)`.\r\n\r\n# Unlicense\r\n\r\nThis is free and unencumbered public domain software. For more information, see http://unlicense.org/ or the accompanying [UNLICENSE](https://github.com/pluma/ary/blob/master/UNLICENSE) file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}